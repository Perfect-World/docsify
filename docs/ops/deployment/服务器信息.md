# 服务器信息

### `server_info.sh``server_info.txt`

```bash
touch /root/wencong/server_info.sh
```

```shell
#!/bin/bash

# 核心：导入配置文件（. 和 source 等价，sh中推荐用.）
# . ./config.txt

# 定义核心路径
SERVER_INFO_PATH="/yykj/backup/server_info.txt"
OS_RELEASE="/etc/os-release"
CHECK_DIR="/"  # 根目录磁盘检测
PING_HOST="8.8.8.8"  # 外网检测节点（Google DNS，稳定）
CURL_URL="http://www.baidu.com"  # curl备选检测节点
CHECK_PORT="22"  # 核心检测端口（统一定义，避免重复）

# 获取当前时间戳（格式：2025-01-01 01:01:01）
CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')

# ====================== 控制台进度输出 - 开始 ======================
printf "【1/9】开始执行服务器信息记录脚本...\n"
printf "输出文件路径: %s\n" "${SERVER_INFO_PATH}"
printf "系统信息命令: %s\n" "${OS_RELEASE}"
printf "外网检测节点: %s/%s\n" "${PING_HOST}" "${CURL_URL}"
# ====================== 控制台进度输出 - 结束 ======================

# 第一步：创建目标文件所在目录
printf "【2/9】创建目标文件所在目录...\n"
mkdir -p "$(dirname "${SERVER_INFO_PATH}")"
if [ $? -eq 0 ]; then
    printf "目录创建成功（或已存在）: %s\n" "$(dirname "${SERVER_INFO_PATH}")"
else
    printf "警告：目录创建失败，但继续执行...\n"
fi

# 第二步：获取OS信息
printf "【3/9】获取操作系统信息...\n"
if [ -f "${OS_RELEASE}" ]; then
    OS_NAME=$(. /etc/os-release && echo "$ID")
    OS_VERSION=$(. /etc/os-release && echo "$VERSION")
    ARCH=$(uname -m)
    OS_INFO="系统: ${OS_NAME} | 版本: ${OS_VERSION} | 架构: ${ARCH} "
else
    OS_INFO="系统: 未知 | 版本: 未知"
fi
printf "操作系统信息: %s\n" "${OS_INFO}"

# 第三步：获取CPU信息（清理型号多余空格）
printf "【4/9】获取CPU核心数和型号...\n"
CPU_INFO="CPU 数量: 未知 | 型号: 未知"
# 优先用lscpu（兼容所有系统）
if command -v lscpu >/dev/null 2>&1; then
    # 提取CPU核心数（兼容所有lscpu输出格式）
    CPU_TOTAL=$(lscpu 2>/dev/null | grep -E '^CPU\(s\):' | awk '{gsub(/^ +| +$/,"");print $2}')
    # 提取CPU型号（彻底清理所有多余空格）
    MODEL_NAME=$(lscpu 2>/dev/null | grep -E '^型号名称：|^Model name:|^Model:' | head -n1 | awk -F '[：:]' '{
        gsub(/^[[:space:]]+/, "", $2);
        gsub(/[[:space:]]+$/, "", $2);
        print $2
    }')
    # 校验是否为数字（兼容sh的grep方式）
    if [ -n "${CPU_TOTAL}" ] && echo "${CPU_TOTAL}" | grep -q '^[0-9]\+$'; then
        # 处理型号为空的情况
        if [ -z "${MODEL_NAME}" ]; then
            MODEL_NAME="未知"
        fi
        CPU_INFO="CPU 数量: ${CPU_TOTAL} | 型号:${MODEL_NAME}"
    fi
# 备选：/proc/cpuinfo
elif [ -f /proc/cpuinfo ]; then
    CPU_TOTAL=$(grep -c ^processor /proc/cpuinfo)
    MODEL_NAME=$(grep -m1 'model name' /proc/cpuinfo | awk -F: '{
        gsub(/^ +| +$/,"");
        gsub(/ +/," ");
        print $2
    }')
    if [ -n "${CPU_TOTAL}" ] && echo "${CPU_TOTAL}" | grep -q '^[0-9]\+$'; then
        if [ -z "${MODEL_NAME}" ]; then
            MODEL_NAME="未知"
        fi
        CPU_INFO="CPU 数量: ${CPU_TOTAL} | 型号:${MODEL_NAME}"
    fi
fi
printf "CPU信息: %s\n" "${CPU_INFO}"

# 第四步：获取根目录磁盘空间（兼容df -h/老旧系统）
printf "【5/9】获取磁盘空间...\n"
DISK_INFO="磁盘空间: 未知"  # 默认值
if command -v df >/dev/null 2>&1; then
    # 检测-h参数是否支持（彻底屏蔽help输出）
    if df -h --help >/dev/null 2>&1; then
        DF_OUTPUT=$(df -h "${CHECK_DIR}" 2>/dev/null | grep -v "^Filesystem" | grep "^/")
        # 格式化磁盘信息：总/空闲/已使用/使用率
        if [ -n "${DF_OUTPUT}" ]; then
            DISK_INFO=$(echo "${DF_OUTPUT}" | awk '{
                printf "磁盘空间: 根: %s  总:%s  空闲:%s  已使用:%s  使用率:%s",
                $1, $2, $4, $3, $5
            }')
        fi
    else
        DF_OUTPUT=$(df -k "${CHECK_DIR}" 2>/dev/null | grep -v "^Filesystem" | grep "^/")
        printf "提示：当前系统df不支持-h参数，使用-k（千字节）格式\n"
        # 格式化千字节版本
        if [ -n "${DF_OUTPUT}" ]; then
            DISK_INFO=$(echo "${DF_OUTPUT}" | awk '{
                printf "磁盘空间: 根: %s  总:%sKB  空闲:%sKB  已使用:%sKB  使用率:%s",
                $1, $2, $4, $3, $5
            }')
        fi
    fi
fi
printf "磁盘空间信息: %s\n" "${DISK_INFO}"

# 第五步：主动访问检测
printf "【6/9】主动访问...\n"
ACTIVE_ACCESS_STATUS="异常"  # 默认值
# 优先用curl（无输出，检测HTTP状态）
if command -v curl >/dev/null 2>&1; then
    curl -s --connect-timeout 5 "${CURL_URL}" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        ACTIVE_ACCESS_STATUS="正常"
    fi
# 备选：ping（短时间，少包，避免阻塞）
elif command -v ping >/dev/null 2>&1; then
    ping -c 1 -W 3 "${PING_HOST}" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        ACTIVE_ACCESS_STATUS="正常"
    fi
fi
printf "主动访问状态: %s\n" "${ACTIVE_ACCESS_STATUS}"

# 第六步：获取内网IP、公网IP、接受访问状态及防火墙基础信息
printf "【7/9】获取网络信息及防火墙基础状态...\n"

# ========== 1. 初始化防火墙相关变量（合并重复定义） ==========
FIREWALL_STATUS="未知"
OPEN_PORTS="未知"
FIREWALL_ALLOWS=0  # 针对检测端口的放行标记
HAS_PUBLIC_LISTEN=0  # 公网接口监听标记

# ========== 2. 获取内网IP ==========
INNER_IP="未知"
if command -v ip >/dev/null 2>&1; then
    INNER_IP=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | grep -v '^127\.' | head -n1 | cut -d'/' -f1)
elif command -v ifconfig >/dev/null 2>&1; then
    INNER_IP=$(ifconfig | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.' | head -n1)
fi

# ========== 3. 获取公网IP ==========
PUBLIC_IP="未知"
# 优先curl获取公网IP
if command -v curl >/dev/null 2>&1; then
    PUBLIC_IP=$(curl -s --connect-timeout 5 icanhazip.com || curl -s --connect-timeout 5 ifconfig.me || echo "未知")
# 备选wget获取
elif command -v wget >/dev/null 2>&1; then
    PUBLIC_IP=$(wget -qO- --timeout=5 icanhazip.com || wget -qO- --timeout=5 ifconfig.me || echo "未知")
fi

# ========== 4. 检测公网接口监听状态（合并到网络检测） ==========
if [ "${PUBLIC_IP}" != "未知" ] && ! echo "${PUBLIC_IP}" | grep -E '^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)'; then
    HAS_PUBLIC_IP=1
    # 检查目标端口是否在公网接口（0.0.0.0）监听
    if command -v netstat >/dev/null 2>&1; then
        if netstat -tuln | grep -qE "0\.0\.0\.0:${CHECK_PORT}|:::${CHECK_PORT}"; then
            HAS_PUBLIC_LISTEN=1
        else
            OUTER_ACCESS_MSG="端口${CHECK_PORT}未监听公网接口（仅内网/回环监听）"
        fi
    elif command -v ss >/dev/null 2>&1; then
        if ss -tuln | grep -qE "0\.0\.0\.0:${CHECK_PORT}|:::${CHECK_PORT}|*${CHECK_PORT}"; then
            HAS_PUBLIC_LISTEN=1
        else
            OUTER_ACCESS_MSG="端口${CHECK_PORT}未监听公网接口（仅内网/回环监听）"
        fi
    else
        OUTER_ACCESS_MSG="无netstat/ss工具，无法检测端口监听状态"
    fi
else
    HAS_PUBLIC_IP=0
    OUTER_ACCESS_MSG="无有效公网IP"
fi

# ========== 5. 防火墙状态及端口放行检测（合并核心逻辑） ==========
# 标记：是否需要继续检测firewalld（默认需要）
NEED_CHECK_FIREWALLD=1

# -------------------- 第一步：检测ufw --------------------
if command -v ufw >/dev/null 2>&1; then
    UFW_RAW_STATUS=$(ufw status 2>/dev/null)
    # 判断ufw是否开启
    if echo "${UFW_RAW_STATUS}" | grep -qiw "active"; then
        FIREWALL_STATUS="ufw开启"
        NEED_CHECK_FIREWALLD=0  # ufw开启，无需检测firewalld
        # 提取ufw开放端口
        OPEN_PORTS=$(echo "${UFW_RAW_STATUS}" | grep -E '^[0-9]' 2>/dev/null | awk '{print $1}' | tr '\n' ',' | sed 's/,$//')
        # 检查目标端口是否放行
        if ufw status 2>/dev/null | grep -qE " ${CHECK_PORT}/tcp +ALLOW +Anywhere" || ufw status 2>/dev/null | grep -qE " ${CHECK_PORT}/udp +ALLOW +Anywhere"; then
            FIREWALL_ALLOWS=1
            # 已开启，不需要检测firewalld
            NEED_CHECK_FIREWALLD=0
        else
            OUTER_ACCESS_MSG="ufw防火墙未放行${CHECK_PORT}端口"
        fi
    elif echo "${UFW_RAW_STATUS}" | grep -qiw "inactive"; then
        FIREWALL_STATUS="ufw关闭"
        OPEN_PORTS="ufw关闭（无开放端口）"
    else
        FIREWALL_STATUS="ufw状态未知（无权限/输出异常）"
        OPEN_PORTS="未知（ufw输出异常）"
    fi
fi

# -------------------- 第二步：检测firewalld（按需执行） --------------------
if [ ${NEED_CHECK_FIREWALLD} -eq 1 ] && command -v firewall-cmd >/dev/null 2>&1; then
    FIREWALLD_RAW_STATUS=$(firewall-cmd --state 2>/dev/null)
    # 判断firewalld是否开启
    if [ "${FIREWALLD_RAW_STATUS}" = "running" ]; then
        # 合并防火墙状态（体现双防火墙）
        if [ "${FIREWALL_STATUS}" != "未知" ]; then
            FIREWALL_STATUS="${FIREWALL_STATUS} + firewalld开启"
        else
            FIREWALL_STATUS="firewalld开启"
        fi
        # 提取firewalld开放端口
        RAW_PORTS=$(firewall-cmd --list-ports 2>/dev/null | tr ' ' ',' | sed 's/,$//')
        # 合并ufw和firewalld的端口（若ufw有端口）
        if [ "${OPEN_PORTS}" != "未知" ] && [ "${OPEN_PORTS}" != "ufw关闭（无开放端口）" ]; then
            OPEN_PORTS="${OPEN_PORTS},${RAW_PORTS:-无}"
        else
            OPEN_PORTS="${RAW_PORTS:-未知}"
        fi
        # 检查目标端口是否放行（只要一个放行则标记为1）
        if firewall-cmd --list-ports 2>/dev/null | grep -qE "22/tcp|80/tcp|443/tcp|3306/tcp"; then
            FIREWALL_ALLOWS=1
            # 覆盖之前的端口未放行提示
            if echo "${OUTER_ACCESS_MSG}" | grep -q "ufw防火墙未放行"; then
                OUTER_ACCESS_MSG=""
            fi
        else
            if [ -z "${OUTER_ACCESS_MSG}" ]; then
                OUTER_ACCESS_MSG="firewalld防火墙未放行${CHECK_PORT}端口"
            else
                OUTER_ACCESS_MSG="${OUTER_ACCESS_MSG}；firewalld也未放行${CHECK_PORT}端口"
            fi
        fi
    elif [ "${FIREWALLD_RAW_STATUS}" = "not running" ]; then
        # 合并防火墙状态
        if [ "${FIREWALL_STATUS}" != "未知" ]; then
            FIREWALL_STATUS="${FIREWALL_STATUS} + firewalld关闭"
        else
            FIREWALL_STATUS="firewalld关闭"
        fi
        OPEN_PORTS="${OPEN_PORTS:-无}（firewalld关闭）"
    else
        # 合并防火墙状态
        if [ "${FIREWALL_STATUS}" != "未知" ]; then
            FIREWALL_STATUS="${FIREWALL_STATUS} + firewalld状态未知"
        else
            FIREWALL_STATUS="firewalld状态未知（无权限/输出异常）"
        fi
        OPEN_PORTS="未知（firewalld输出异常）"
    fi
# 无防火墙工具的兜底
elif [ ${NEED_CHECK_FIREWALLD} -eq 1 ]; then
    if [ "${FIREWALL_STATUS}" = "未知" ]; then
        FIREWALL_STATUS="未检测到防火墙工具（ufw/firewalld）"
        OPEN_PORTS="未知（无检测工具）"
        FIREWALL_ALLOWS=1  # 默认允许（兼容旧系统）
    fi
fi

# 补充：防火墙开启但端口为空时，检测监听端口
if [ "${FIREWALL_STATUS}" = "开启" ] && ( [ "${OPEN_PORTS}" = "未知" ] || [ -z "${OPEN_PORTS}" ] ); then
    if command -v netstat >/dev/null 2>&1; then
        OPEN_PORTS=$(netstat -tuln | grep -E ':22|:80|:443|:8080' | awk '{print $4}' | cut -d':' -f2 | sort -n | uniq | tr '\n' ',' | sed 's/,$//')
    elif command -v ss >/dev/null 2>&1; then
        OPEN_PORTS=$(ss -tuln | grep -E ':22|:80|:443|:8080' | awk '{print $5}' | cut -d':' -f2 | sort -n | uniq | tr '\n' ',' | sed 's/,$//')
    fi
    # 兜底处理
    OPEN_PORTS="${OPEN_PORTS:-无}"
fi

# ========== 6. 外网实际可达性检测 ==========
OUTER_ACCESS=0  # 外网实际可达标记：0=不可达/未知，1=可达
if [ ${FIREWALL_ALLOWS} -eq 1 ] && [ ${HAS_PUBLIC_LISTEN} -eq 1 ]; then
    printf "  正在检测外网是否可访问 ${PUBLIC_IP}:${CHECK_PORT}...\n"
    
    # 方法1：nc检测（优先）
    if command -v nc >/dev/null 2>&1; then
        NC_RESULT=$(nc -zvw 5 ${PUBLIC_IP} ${CHECK_PORT} 2>&1)
        if echo "${NC_RESULT}" | grep -qiw "succeeded\|open"; then
            OUTER_ACCESS=1
            OUTER_ACCESS_MSG="nc检测通过"
        else
            OUTER_ACCESS_MSG="nc检测失败：${NC_RESULT}"
        fi
    # 方法2：telnet检测（备选）
    elif command -v telnet >/dev/null 2>&1 && command -v timeout >/dev/null 2>&1; then
        TELNET_RESULT=$(timeout 5 telnet ${PUBLIC_IP} ${CHECK_PORT} 2>&1)
        if echo "${TELNET_RESULT}" | grep -qiw "Connected\|Escape character"; then
            OUTER_ACCESS=1
            OUTER_ACCESS_MSG="telnet检测通过"
        else
            OUTER_ACCESS_MSG="telnet检测失败：${TELNET_RESULT}"
        fi
    else
        OUTER_ACCESS_MSG="无nc/telnet工具，无法检测外网可达性"
    fi
    # 方法3：第三方检测（兜底，公网视角，https://www.ip33.com/port_scan.html）
    if [ ${OUTER_ACCESS} -eq 0 ] && command -v curl >/dev/null 2>&1; then
        printf "  尝试第三方接口检测（站长工具）...\n"
        # 构造请求（简化Cookie，避免过期）
        SCAN_RESULT=$(curl -sS --connect-timeout 5 -m 5 \
        'https://api.ip33.com/port_scan/scan' \
        -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' \
        -d "ip=${PUBLIC_IP}&port=${CHECK_PORT}&time=3000" 2>/dev/null)
        # 判断curl是否超时/无响应
        if [ -z "${SCAN_RESULT}" ]; then
            OUTER_ACCESS_MSG="检测失败：接口请求超时（5秒）或无响应"
        else
            CLEAN_SCAN_RESULT=$(echo "${SCAN_RESULT}" | tr -d ' \t\n\r')
            if echo "${CLEAN_SCAN_RESULT}" | grep -iw '"state":true'; then
                OUTER_ACCESS=1
                OUTER_ACCESS_MSG="检测通过：${PUBLIC_IP}:${CHECK_PORT} 端口开放"
            elif echo "${SCAN_RESULT}" | grep -iw '"state":false'; then
                OUTER_ACCESS_MSG="检测失败：${PUBLIC_IP}:${CHECK_PORT} 端口关闭"
            fi
        fi
    fi
fi

# ========== 7. 综合判定接受访问状态 ==========
PASSIVE_ACCESS_STATUS="未知"
if [ ${HAS_PUBLIC_IP} -eq 1 ] && [ ${HAS_PUBLIC_LISTEN} -eq 1 ] && [ ${FIREWALL_ALLOWS} -eq 1 ] && [ ${OUTER_ACCESS} -eq 1 ]; then
    PASSIVE_ACCESS_STATUS="是(${OUTER_ACCESS_MSG})"
elif [ ${HAS_PUBLIC_IP} -eq 0 ]; then
    PASSIVE_ACCESS_STATUS="否(无有效公网IP)"
elif [ ${HAS_PUBLIC_LISTEN} -eq 0 ]; then
    PASSIVE_ACCESS_STATUS="否(端口${CHECK_PORT}未监听公网接口)"
#elif [ ${FIREWALL_ALLOWS} -eq 0 ]; then
#    PASSIVE_ACCESS_STATUS="否(防火墙未允许外部访问端口${CHECK_PORT})"
elif [ ${OUTER_ACCESS} -eq 0 ]; then
    PASSIVE_ACCESS_STATUS="否(外网无法访问：${OUTER_ACCESS_MSG}，可能是安全组/路由拦截)"
fi
if [ ${FIREWALL_ALLOWS} -eq 0 ]; then
	PASSIVE_ACCESS_STATUS="否(防火墙未允许外部访问端口${CHECK_PORT})"
fi

# 构造IP信息
IP_INFO="内网ip: ${INNER_IP} | 公网ip: ${PUBLIC_IP} | 主动访问: ${ACTIVE_ACCESS_STATUS} | 接受访问: ${PASSIVE_ACCESS_STATUS}"
printf "IP信息: %s\n" "${IP_INFO}"

# 第七步：整理防火墙详细信息（直接使用已计算的变量）
printf "【8/9】整理防火墙状态和端口信息...\n"
FIREWALL_INFO="防火墙: ${FIREWALL_STATUS} | 端口号: ${OPEN_PORTS}"
printf "防火墙信息: %s\n" "${FIREWALL_INFO}"

# 第八步：构造完整内容并写入文件顶部
printf "【9/9】将所有信息写入目标文件顶部...\n"
# 构造内容（严格匹配指定格式）
NEW_CONTENT=$(printf "========%s========\n%s\n%s\n%s\n%s\n%s" \
    "${CURRENT_TIME}" \
    "${IP_INFO}" \
    "${FIREWALL_INFO}" \
    "${OS_INFO}" \
    "${CPU_INFO}" \
    "${DISK_INFO}")

# 临时文件法（原子操作，避免文件损坏）
TEMP_FILE=$(mktemp /tmp/server_info_XXXXXX.txt)
printf "%s\n" "${NEW_CONTENT}" > "${TEMP_FILE}"
# 追加原有内容
if [ -f "${SERVER_INFO_PATH}" ]; then
    cat "${SERVER_INFO_PATH}" >> "${TEMP_FILE}"
fi
# 替换目标文件
mv "${TEMP_FILE}" "${SERVER_INFO_PATH}"

# ====================== 最终执行结果 ======================
printf "脚本执行完成！\n"
printf "最新记录已插入到文件顶部：head -n 10 %s\n" "${SERVER_INFO_PATH}"
```



```shell
#!/bin/bash

# 定义核心路径
TARGET_FILE="/root/wencong/server_info.txt"
OS_RELEASE="/etc/os-release"
CHECK_DIR="/"  # 根目录磁盘检测
PING_HOST="8.8.8.8"  # 外网检测节点（Google DNS，稳定）
CURL_URL="http://www.baidu.com"  # curl备选检测节点

# ====================== 控制台进度输出 - 开始（纯文本） ======================
echo -e "\n【1/7】开始执行服务器信息记录脚本..."
echo "目标文件路径: ${TARGET_FILE}"
echo "检查的配置文件: ${OS_RELEASE}"
echo "外网检测节点: ${PING_HOST}/${CURL_URL}"
# ====================== 控制台进度输出 - 结束 ======================

# 第一步：创建目标文件所在目录
echo -e "\n【2/7】创建目标文件所在目录..."
mkdir -p "$(dirname "${TARGET_FILE}")"
if [ $? -eq 0 ]; then
    echo "目录创建成功（或已存在）: $(dirname "${TARGET_FILE}")"
else
    echo "警告：目录创建失败，但继续执行..."
fi

# 第二步：获取OS信息
echo -e "\n【3/7】获取操作系统信息..."
if [ -f "${OS_RELEASE}" ]; then
    OS_INFO=$(grep -E '^NAME=|^VERSION=' "${OS_RELEASE}" | tr '\n' '  ')
    OS_INFO=$(echo "${OS_INFO}" | sed -e 's/  */  /g')
else
    OS_INFO="命令os-release无效"
fi
echo "操作系统信息: ${OS_INFO}"

# 第三步：获取CPU核心数（兼容本地化/无lscpu场景）
echo -e "\n【4/7】获取CPU核心数..."
CPU_INFO="命令cpu无效"  # 默认值
# 优先用lscpu（兼容括号转义）
if command -v lscpu &>/dev/null; then
    # 机器可读格式，避免本地化字段问题
    CPU_TOTAL=$(lscpu --parse="CPU(s)" 2>/dev/null | head -n1 | awk -F: '{gsub(/^ /,"");print $2}')
    if [ -n "${CPU_TOTAL}" ] && [[ "${CPU_TOTAL}" =~ ^[0-9]+$ ]]; then
        CPU_INFO="cpu ${CPU_TOTAL}"
    fi
# 备选：读取/proc/cpuinfo（所有Linux内核标配）
elif [ -f /proc/cpuinfo ]; then
    CPU_TOTAL=$(grep -c ^processor /proc/cpuinfo)
    if [ -n "${CPU_TOTAL}" ] && [[ "${CPU_TOTAL}" =~ ^[0-9]+$ ]]; then
        CPU_INFO="cpu ${CPU_TOTAL}"
    fi
fi
echo "CPU核心数信息: ${CPU_INFO}"

# 第四步：获取根目录磁盘空间（兼容df -h/老旧系统）
echo -e "\n【5/7】获取根目录磁盘空间..."
DISK_INFO="命令df无效"  # 默认值
if command -v df &>/dev/null; then
    # 检测-h参数是否支持
    if df -h --help &>/dev/null; then
        DF_OUTPUT=$(df -h "${CHECK_DIR}" 2>/dev/null | grep -v "^Filesystem" | grep "^/")
    else
        DF_OUTPUT=$(df -k "${CHECK_DIR}" 2>/dev/null | grep -v "^Filesystem" | grep "^/")
        echo "提示：当前系统df不支持-h参数，使用-k（千字节）格式"
    fi
    if [ -n "${DF_OUTPUT}" ]; then
        DISK_INFO="磁盘空间(根目录): ${DF_OUTPUT}"
    fi
fi
echo "磁盘空间信息: ${DISK_INFO}"

# 第五步：外网访问检测（兼容ping/curl，避免ICMP禁用）
echo -e "\n【6/7】检测外网访问..."
NETWORK_INFO="命令外网检测无效"  # 默认值
# 优先用curl（无输出，检测HTTP状态）
if command -v curl &>/dev/null; then
    curl -s --connect-timeout 5 "${CURL_URL}" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        NETWORK_INFO="外网访问: 正常"
    else
        NETWORK_INFO="外网访问: 异常"
    fi
# 备选：ping（短时间，少包，避免阻塞）
elif command -v ping &>/dev/null; then
    ping -c 1 -W 3 "${PING_HOST}" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        NETWORK_INFO="外网访问: 正常"
    else
        NETWORK_INFO="外网访问: 异常"
    fi
fi
echo "外网检测信息: ${NETWORK_INFO}"

# 第六步：构造完整内容并写入文件顶部
echo -e "\n【7/7】将所有信息写入目标文件顶部..."
CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')
# 构造内容（每行一个信息，格式整洁）
NEW_CONTENT=$(printf "========%s========\n%s\n%s\n%s\n%s" \
    "${CURRENT_TIME}" \
    "${OS_INFO}" \
    "${CPU_INFO}" \
    "${DISK_INFO}" \
    "${NETWORK_INFO}")

# 临时文件法（原子操作，避免文件损坏）
TEMP_FILE=$(mktemp /tmp/server_info_XXXXXX.txt)
printf "%s\n" "${NEW_CONTENT}" > "${TEMP_FILE}"
# 追加原有内容
if [ -f "${TARGET_FILE}" ]; then
    cat "${TARGET_FILE}" >> "${TEMP_FILE}"
    echo "目标文件已存在，追加原有内容到临时文件"
fi
# 替换目标文件
mv "${TEMP_FILE}" "${TARGET_FILE}"

# ====================== 最终执行结果 ======================
echo -e "\n脚本执行完成！"
echo "最新记录已插入到文件顶部：${TARGET_FILE}"
echo -e "\n文件最新内容预览："
head -n 6 "${TARGET_FILE}"
echo "..."
```



